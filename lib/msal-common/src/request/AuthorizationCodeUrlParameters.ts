/*
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */

import { AuthorizationClientConfiguration } from "../config/AuthorizationClientConfiguration";
import { RequestValidator } from "./RequestValidator";
import { ServerParamsGenerator } from "../server/ServerParamsGenerator";

/**
 * @type AuthorizationCodeUrlParameters: Request object passed by user to retrieve a Code from the server (first leg of authorization code grant flow)
 *
 * scopes:                  A space-separated list of scopes. For OpenID Connect, it must include the scope openid,
 *                          which translates to the "Sign you in" permission in the consent UI.
 *                          You might also include other scopes in this request for requesting consent.
 *
 * authority:               authorization endpoint that grants the code to the application
 *
 * redirectUri:             The redirect URI of your app, where authentication responses can be sent and received by your app.
 *                          It must exactly match one of the redirect URIs you registered in the portal,
 *                          except that it must be URL encoded. If not present, the endpoint will pick one registered
 *                          redirect_uri at random to send the user back to.
 *
 * codeChallenge:           codeChallenge generated by the user
 *
 * codeChallengeMethod:     method used to generate the code (eg: SHA256)
 *
 * state:                   A value included in the request that also will be returned in the token response.
 *                          It can be a string of any content you want. A randomly generated unique value typically is used to
 *                          prevent cross-site request forgery attacks. The state also is used to encode information about the user's
 *                          state in the app before the authentication request occurred, such as the page or view the user was on.
 *
 * prompt:                  ndicates the type of user interaction that is required. The only valid values at this time are
 *                          login, none, and consent. The prompt=login claim forces the user to enter their credentials on that request,
 *                          which negates single sign-on. The prompt=none claim is the opposite. This claim ensures that the user
 *                          isn't presented with any interactive prompt at. If the request can't be completed silently via single
 *                          sign-on, the Microsoft identity platform endpoint returns an error. The prompt=consent claim triggers
 *                          the OAuth consent dialog after the user signs in. The dialog asks the user to grant permissions to the app.
 *
 * loginHint:               You can use this parameter to pre-fill the username and email address field of the sign-in page for
 *                          the user, if you know the username ahead of time. Often, apps use this parameter during reauthentication,
 *                          after already extracting the username from an earlier sign-in by using the preferred_username claim.
 *
 * domainHint:              The realm of the user in a federated directory. This skips the email-based discovery process
 *                          that the user goes through on the sign-in page, for a slightly more streamlined user experience.
 *                          For tenants that are federated through an on-premises directory like AD FS,
 *                          this often results in a seamless sign-in because of the existing login session.
 *
 * claimsRequest:           facilitate the user to pass in "claims" requested the service for conditional access (CA),
 *                          typically after CA fail
 *
 * nonce:                   A value included in the request, generated by the app, that will be included in the
 *                          resulting id_token value as a claim. The app can verify this value to mitigate token replay attacks.
 *                          The value typically is a randomized, unique string that can be used to identify the origin of the request.
 *
 * correlationId:           Unique GUID set per request to trace a request end-to-end for telemetry purposes
 *
 *
 * This "Request" parameter is called when `msal-node` makes the authorization code request to the service on behalf of the app
 */
export class AuthorizationCodeUrlParameters {
    scopes?: Array<string>;
    authority?: string;
    redirectUri?: string;
    codeChallenge?: string;
    codeChallengeMethod?: string;
    state?: string;
    prompt?: string;
    loginHint?: string;
    domainHint?: string;
    claimsRequest?: string;
    nonce?: string;
    correlationId?: string;

    /**
     * This API validates the `AuthorizationCodeUrlParameters` and creates a URL to be sent to the server
     * @param request
     * @param config
     */
    static generateAuthCodeUrlParams(
        request: AuthorizationCodeUrlParameters,
        config: AuthorizationClientConfiguration
    ) {
        const paramsMap: Map<string, string> = new Map<string, string>();

        // add clientId
        ServerParamsGenerator.addClientId(paramsMap, config.auth.clientId);

        // validate and add scopes
        const scopes = RequestValidator.validateAndGenerateScopes(
            request.scopes,
            config.auth.clientId
        );
        ServerParamsGenerator.addScopes(paramsMap, scopes);

        // validate the redirectUri (to be a non null value)
        RequestValidator.validateRedirectUri(request.redirectUri);
        ServerParamsGenerator.addRedirectUri(paramsMap, request.redirectUri);

        // validate and pass code_challenge Params
        RequestValidator.validateCodeChallengeParams(request.codeChallenge, request.codeChallengeMethod);
        ServerParamsGenerator.addCodeChallengeParams(paramsMap, request.codeChallenge, request.codeChallengeMethod);

        // add state - user set, no validation needed (preferably a UUID)
        if (request.state) {
            ServerParamsGenerator.addState(paramsMap, request.state);
        }

        // validate and add prompt
        if (request.prompt) {
            RequestValidator.validatePrompt(request.prompt);
            ServerParamsGenerator.addPrompt(paramsMap, request.prompt);
        }

        // add login_hint: user set, no validation needed
        if (request.loginHint) {
            ServerParamsGenerator.addLoginHint(paramsMap, request.loginHint);
        }

        // add domain_hint: user set, no validation needed
        if (request.domainHint) {
            ServerParamsGenerator.addDomainHint(paramsMap, request.domainHint);
        }

        // add domain_hint: user set, no validation needed (preferably a UUID)
        if (request.nonce) {
            ServerParamsGenerator.addNonce(paramsMap, request.nonce);
        }

        // generate the correlationId if not set by the user and add
        const correlationId = request.correlationId
            ? request.correlationId
            : config.cryptoInterface.createNewGuid();
        ServerParamsGenerator.addCorrelationId(paramsMap, correlationId);

        // add response_mode = fragment (currently hardcoded, have a future option to pass 'query' if the user chooses to)
        ServerParamsGenerator.addResponseMode(paramsMap);

        // add response_type = code
        ServerParamsGenerator.addResponseTypeCode(paramsMap);

        return paramsMap;
    }
}
